# config.yaml

# Privilege mode that instructions are executed in
# Options: m/s/u
# Note: If the privilege mode is either s or u, then the test_entry_macro
# will be defined accordingly
priv-mode:
  mode: m

# General directives to aapg
# Options:
#   total_instructions: Approximate number of instructions to be generated by aapg.
#                      The actual number may vary.
#   regs_not_use: Comma-separated list of RISC-V registers to not use for reading/writing
general:
  total_instructions: 1000
  regs_not_use: x1,x2

# Distribution of instructions according to ISA extensions
# Specify the relative frequency of each set
# E.g. : A relative frequency of 1 each means each instruction will be
# generated an equal number of times in the total instructions.
# Specify 0 to disable.
isa-instruction-distribution:
  rel_rv32i.compute: 10
  rel_rv32i.data: 5

# Recursion options
# Options:
#   recursion-enable: Generate the template for recursion or not
#   recursion-depth: Number of times the recursive function is called
recursion-options:
  recursion-enable: true
  recursion-depth: 5

# Data access sections
# Specify which regions of memory will be accessed by the random program
access-sections:
  begin_signature: 0x80091000,0x80095000,rw

# CSR sections
# Specify which CSRs will be accessed by the random program
csr-sections:
  sections: 0x0100:0x01ff, 0x500:0x5ff

# User template sections
# Allows users to specify call to a custom function with the number of times to call
user-functions:
  custom_func1: '{2:"addi x1, x1, 1"}'
  custom_func2: '{3:"sw x2, 0(x1)"}'

# Switching Privilege modes in AAPG
# Options:
#   switch_modes: true/false (Do not provide any user-defined functions when
#                 shifting modes is true)
#   num_switches: # of times privilege modes have to shift (This is randomized,
#                 and shifting may result in the same mode)
switch-priv-modes:
  switch_modes: false
  num_switches: 2

# Self Checking
# If the self_checking flag is enabled during the gen command, the below section is used
# Options:
#   rate: The interval at which checksums are added to the test.
#         If rate = 10, checksums will be added every 10 instructions
self-checking:
  rate: 100
  test_pass_macro: "la      sp, begin_signature;
                    addi    sp, sp, 2*REGBYTES;
                    li      t1, 0xfffff;
                    SREG    t1, 0*REGBYTES(sp)"
  test_fail_macro: "add x0, x0, x0"
